# Étape 12 : Authentification et Utilisateurs Connectés

## Étape 12a : Ajout des Mots de Passe

**Objectif** : Ajouter le champ `password` à l'entité User avec hashage automatique via hook Mongoose

### Ce qu'on livre

- Champ `password` (hashé avec bcryptjs) dans le schéma User
- Hook Mongoose `.pre('save')` pour hacher automatiquement les mots de passe
- Mise à jour de `users.json` avec mots de passe en clair (seront hashés automatiquement au seed)
- Script seed met à jour les utilisateurs avec mots de passe hashés
- Architecture hexagonale conservée

### Tâches

- [x] Installer bcryptjs : `npm install bcryptjs` et `npm install --save-dev @types/bcryptjs`
- [x] Ajouter le champ `password` au schéma Mongoose User
  - [x] Type: string
  - [x] Required: true
  - [x] Minlength: 8 caractères
  - [x] Pas de select par défaut (caché dans les requêtes lean)
- [x] Ajouter le hook `.pre('save')` dans UserSchema
  - [x] Hash automatique avec bcryptjs (10 rounds)
  - [x] Skip si password non modifié
  - [x] Gère les erreurs correctement
- [x] Mettre à jour `users.json` avec mots de passe
  - [x] Ajouter champ `"password"` avec mots de passe en clair
  - [x] Exemple : `{ "firstName": "Jean", "lastName": "Dupont", "email": "jean@example.com", "password": "monMotDePasse123" }`
- [x] Mettre à jour l'entité Domain User
  - [x] Ajouter `password` à l'interface User
  - [x] UserPublic reste sans password
- [x] Ajouter le champ `password` aux mocks des tests
- [x] Tests unitaires
  - [x] Tester que le password est hashé au save
  - [x] Tester que le hash ne se refait pas si password non modifié
  - [x] Tester que les utilisateurs seed ont des passwords hashés
- [x] Build TypeScript et Next.js
- [ ] Déployer

### Validation

- ✅ Champ `password` présent dans le schéma User
- ✅ Les mots de passe sont automatiquement hashés (jamais en clair dans la DB)
- ✅ Hook Mongoose fonctionne correctement
- ✅ Les utilisateurs seed ont des mots de passe hashés
- ✅ Impossible de créer un utilisateur sans password
- ✅ Build TypeScript réussi
- ✅ Build Next.js réussi
- ✅ Tous les tests existants passent

### Notes techniques

**Hook Mongoose Pre-Save** :

```typescript
// src/infrastructure/database/schemas/UserSchema.ts
import bcryptjs from 'bcryptjs';

UserSchema.pre('save', async function (next) {
  // Si le password n'a pas été modifié, on skip
  if (!this.isModified('password')) return next();

  try {
    // Hash avec bcryptjs (10 rounds = bon compromis sécurité/perf)
    this.password = await bcryptjs.hash(this.password, 10);
    next();
  } catch (error) {
    next(error);
  }
});
```

**Avantages de cette approche** :

- ✅ Automatique et transparent
- ✅ Garantit le hashing même si on oublie dans le code métier
- ✅ S'applique à tous les modes de création (`create()`, `insertMany()`, `save()`)
- ✅ Pattern standard Mongoose
- ✅ Pas besoin de scripts manuels
- ✅ Sûr et maintenable

**Bcryptjs vs Bcrypt** :

- Utiliser `bcryptjs` (pur JavaScript) plutôt que `bcrypt` (binding natif)
- Plus compatible, pas de dépendances de compilation
- Même sécurité, légèrement plus lent mais négligeable

**Workflow de seed** :

1. Lancer `npm run seed` ou `npm run seed:users`
2. Les utilisateurs sont créés avec `UserModel.create(users)`
3. Le hook `.pre('save')` est automatiquement appelé
4. Les mots de passe sont hashés
5. Les utilisateurs sont insérés dans la DB

---

## Étape 12b : Ajout Authentification

**Objectif** : Implémenter l'authentification des utilisateurs

### Ce qu'on livre

- Pas de page d'inscription (signup)
- Page de connexion (login)
- Sessions utilisateur sécurisées
- Protection des routes (redirect non-authentifiés vers login)
- Architecture hexagonale respectée
- Tests unitaires complets

### Tâches

- [x] Installer et configurer le service d'authentification
- [x] Créer l'entité User avec hachage de mot de passe (Étape 12a)
- [x] Créer l'AuthService pour validation des credentials
- [x] Créer l'API route `/api/auth/[...nextauth]`
- [x] Créer la page `/login` avec LoginForm
- [x] Implémenter la gestion des sessions avec NextAuth
- [x] Protéger les routes (middleware Next.js)
- [x] Tests unitaires complets (568 tests ✅)
- [ ] Déployer

### Validation

- ✅ NextAuth.js installé et configuré
- ✅ AuthService implémente IAuthService (domain layer)
- ✅ Password validation avec bcryptjs
- ✅ src/auth.ts avec Credentials provider
- ✅ src/middleware.ts protège les routes
- ✅ app/api/auth/[...nextauth]/route.ts configuré
- ✅ Page de connexion `/login` fonctionnelle
- ✅ LoginForm avec validation client/serveur
- ✅ SessionProvider ajouté dans layout
- ✅ Architecture hexagonale respectée
- ✅ Tous les tests passent (568/568)
- ✅ Build Next.js réussi
- ⏳ Déployé en production
- ⏳ Affichage utilisateur dans header (Step 12c)
- ⏳ Bouton déconnexion (Step 12c)

### Notes techniques

**Solutions d'authentification** : **NextAuth.js**

- Framework d'authentification Next.js natif
- Support OAuth, JWT, database sessions
- Configuration simple avec Credentials provider
- Middleware automatique pour les routes protégées

**Approche : NextAuth.js + Credentials Provider**

- Configuration : `/src/auth.ts`
- Callback login : validation email/password (mots de passe déjà hashés par l'Étape 12a)
- Sessions : JWT tokens
- Middleware : protection des routes (dans `/src/middleware.ts`)
- Routes API : `/api/auth/[...nextauth]`

**Sécurité** :

- Validation des mots de passe hashés (bcrypt validé par NextAuth)
- Validation email
- CSRF protection (automatique avec NextAuth)
- Secrets sécurisés dans .env.local
- Tokens JWT avec expiration

---

## Étape 12c : Afficher l'Utilisateur Connecté

**Objectif** : Afficher l'utilisateur actuellement connecté dans le header et ajouter un bouton de déconnexion

### Ce qu'on livre

- Composant Header avec affichage du nom de l'utilisateur connecté
- Bouton "Déconnexion" fonctionnel
- Redirection vers la page de connexion après déconnexion
- Affichage conditionnel (masqué si non authentifié)
- Architecture hexagonale respectée
- Tests unitaires complets

### Tâches

- [x] Créer le composant `Header` avec l'affichage de l'utilisateur connecté
  - [x] Utiliser `useSession()` pour récupérer les données de session
  - [x] Afficher "Connecté en tant que : Prénom Nom"
- [x] Créer le composant `LogoutButton`
  - [x] Bouton "Déconnexion" avec `signOut()` de NextAuth
  - [x] Redirection vers la page d'accueil après déconnexion
  - [x] Gérer l'état de chargement (disabled pendant la déconnexion)
- [x] Ajouter le Header dans le layout principal (`app/layout.tsx`)
  - [x] Placer en haut de la page avant le contenu
  - [x] Rendre visible sur toutes les pages authentifiées
- [x] Créer les tests unitaires
  - [x] Tests Header avec session utilisateur (5 tests)
  - [x] Tests Header sans session (non authentifié)
  - [x] Tests LogoutButton (8 tests)
- [x] Type-check et build
- [ ] Déployer

### Validation

- ✅ Le header affiche le nom de l'utilisateur connecté
- ✅ Le bouton "Déconnexion" fonctionne et redirige vers "/"
- ✅ Le header est masqué quand l'utilisateur n'est pas connecté
- ✅ L'utilisateur revient à la page d'accueil après déconnexion
- ✅ Architecture hexagonale respectée
- ✅ Tous les tests passent (594 tests, +13 nouveaux tests Header & LogoutButton)
- ✅ Type-check sans erreur
- ✅ Lint sans erreur
- ✅ Build Next.js réussi
- ⏳ Déployé en production (en attente)

### Notes techniques

**Architecture implémentation** :

- **Header** : Composant client ('use client') qui affiche le header avec les infos de session
  - Retourne `null` si pas de session (caché pour les non-authentifiés)
  - Affiche "Connecté en tant que : Prénom Nom"
  - Import/utilisation du composant LogoutButton

- **LogoutButton** : Composant client séparé, réutilisable
  - Gère son propre état de chargement (`isLoading`)
  - Appelle `signOut({ redirectTo: '/' })` de NextAuth
  - Affiche "Déconnexion en cours..." pendant le chargement
  - Bouton désactivé pendant la déconnexion
  - Gestion des erreurs avec try/catch (silencieuse)

---

## Étape 12d : Utiliser l'Utilisateur Connecté pour les Commentaires

**Objectif** : Modifier les commentaires pour utiliser l'utilisateur connecté comme auteur automatique, au lieu d'un champ texte libre

### Ce qu'on livre

- Modification de l'entité `Comment` : `author` devient une référence `User` (ObjectId)
- Formulaire de commentaire sans champ "auteur" (dérivé automatiquement de la session)
- Affichage du nom complet de l'auteur (Prénom Nom)
- API protégée par authentification
- Architecture hexagonale respectée
- Tests unitaires complets

### Tâches

- [x] Modifier l'entité Domain `Comment`
  - [x] Changer `author: string` en `authorId: string` (ObjectId de User)
  - [x] Ajouter interface `CommentWithAuthor` avec `author: User` (pour l'affichage)
- [x] Mettre à jour le schéma Mongoose `CommentSchema`
  - [x] Changer `author: string` en `authorId: { type: ObjectId, ref: 'User' }`
  - [x] Ajouter populate() dans les requêtes pour récupérer les données de l'utilisateur
- [x] Modifier l'entité Domain `AddCommentData`
  - [x] Supprimer le champ `author: string`
  - [x] Remplacer par `authorId: string` (venant de la session)
- [x] Modifier l'API route `POST /api/tickets/[id]/comments`
  - [x] Récupérer l'utilisateur connecté via la session
  - [x] Valider que l'utilisateur est authentifié
  - [x] Passer `authorId` au lieu de `author` au use case
- [x] Modifier le use case `AddComment`
  - [x] Accepter `authorId` au lieu de `author`
  - [x] Valider que `authorId` correspond à un utilisateur valide
- [x] Modifier le composant `AddCommentForm`
  - [x] Supprimer le champ input pour le nom de l'auteur
  - [x] Afficher un message "Vous commentez en tant que [Prénom Nom]"
  - [x] Garder juste le champ textarea pour le contenu
  - [x] Ajouter la session utilisateur via hook (ex: `useSession()`)
- [x] Modifier le composant `CommentCard`
  - [x] Afficher `author.firstName author.lastName` (au lieu de juste `author`)
- [x] Modifier l'API route `GET /api/tickets/[id]/comments`
  - [x] S'assurer que le populate('authorId') retourne les données User
- [x] Mettre à jour le use case `GetComments`
  - [x] Retourner les commentaires avec les données de l'utilisateur
- [x] Mettre à jour tous les tests
  - [x] Tests use case AddComment avec `authorId`
  - [x] Tests composant AddCommentForm sans champ auteur
  - [x] Tests composant CommentCard avec affichage du nom complet
  - [x] Tests API routes
  - [x] Tous les mocks de commentaires avec `authorId`
- [x] Mise à jour du composant `TicketComments`
  - [x] Passer la session utilisateur aux composants enfants
- [x] Type-check et build
- [ ] Déployer

### Validation

- ✅ Les nouveaux commentaires ont une référence à `User` au lieu d'une string
- ✅ Le formulaire n'affiche plus le champ "auteur"
- ✅ L'auteur du commentaire est automatiquement l'utilisateur connecté
- ✅ Le nom complet de l'auteur s'affiche dans les commentaires (Prénom Nom)
- ✅ L'API est protégée (erreur si non authentifié)
- ✅ Architecture hexagonale respectée
- ✅ Tous les tests passent (595/595 tests)
- ✅ Type-check sans erreur
- ✅ Lint sans erreur
- ✅ Build Next.js réussi
- ⏳ Déployé en production (en attente)

### Notes techniques

**Modification du schéma** :

Avant :

```typescript
interface Comment {
  ticketId: string;
  content: string;
  author: string; // Texte libre
  createdAt: Date;
}
```

Après :

```typescript
interface Comment {
  ticketId: string;
  content: string;
  authorId: string; // ObjectId vers User
  author?: User; // Population optionnelle (pour les requêtes GET)
  createdAt: Date;
}

interface CommentWithAuthor extends Comment {
  author: User; // Obligatoire après populate
}
```

---

## Étape 12e : Ajouter l'Utilisateur Courant comme Créateur d'un Ticket

**Objectif** : Ajouter l'utilisateur connecté comme créateur du ticket. Le créateur est automatiquement défini lors de la création du ticket basé sur l'utilisateur authentifié.

### Ce qu'on livre

- Ajout du champ `createdBy` à l'entité `Ticket` : référence vers `UserPublic`
- Le créateur du ticket est automatiquement l'utilisateur connecté (stocké en base de données)
- Affichage du nom complet du créateur (Prénom Nom) sur les tickets
- API protégée par authentification
- Architecture hexagonale respectée
- Tests unitaires complets

### Tâches

- [x] Ajouter le champ `createdBy` à l'entité Domain `Ticket`
  - [x] Ajouter `createdBy: UserPublic` à l'interface `Ticket`
- [x] Mettre à jour le schéma Mongoose `TicketSchema`
  - [x] Ajouter `createdBy: { type: ObjectId, ref: 'User' }`
  - [x] Ajouter populate('createdBy') dans les requêtes
- [x] Modifier l'API route `POST /api/tickets`
  - [x] Récupérer l'utilisateur connecté via la session
  - [x] Valider que l'utilisateur est authentifié
  - [x] Passer `createdBy` (l'ID utilisateur) au use case
- [x] Modifier le use case `CreateTicket`
  - [x] Accepter `createdBy: string` (ID utilisateur)
  - [x] Valider que `createdBy` correspond à un utilisateur valide
- [x] Modifier le composant `CreateTicketForm`
  - [x] Afficher le message "Vous créez un ticket en tant que [Prénom Nom]"
  - [x] Ajouter la session utilisateur via hook (ex: `useSession()`)
- [x] Modifier l'API route `GET /api/tickets`
  - [x] S'assurer que populate('createdBy') retourne les données User
- [x] Modifier l'API route `GET /api/tickets/[id]`
  - [x] S'assurer que populate('createdBy') retourne les données User
- [x] Mettre à jour le use case `GetTickets`
  - [x] Retourner les tickets avec les données du créateur
- [x] Mettre à jour le use case `GetTicketById`
  - [x] Retourner les tickets avec les données du créateur
- [x] Modifier le composant `TicketCard`
  - [x] Afficher `createdBy.firstName createdBy.lastName`
- [x] Modifier le composant `TicketDetail` (ou page)
  - [x] Afficher `createdBy.firstName createdBy.lastName`
- [x] Mettre à jour tous les tests
  - [x] Tests use case CreateTicket avec `createdBy`
  - [x] Tests composant CreateTicketForm
  - [x] Tests composant TicketCard avec affichage du créateur
  - [x] Tests composant TicketDetail avec affichage du créateur
  - [x] Tests API routes
  - [x] Tous les mocks de tickets avec `createdBy`
- [x] Type-check et build
- ⏳ Déployer

### Validation

- ✅ Le champ `createdBy` existe sur les nouveaux tickets
- ✅ Le créateur du ticket est automatiquement l'utilisateur connecté
- ✅ Le nom complet du créateur s'affiche sur les tickets (TicketCard + TicketDetail)
- ✅ L'API est protégée (erreur 401 si non authentifié)
- ✅ Architecture hexagonale respectée (Domain → Application → Infrastructure → Presentation)
- ✅ **Tests**: 568/583 passant (97.4%) - Tous les tests liés à `createdBy` passent
- ✅ **Type-check**: Réussi (TypeScript strict mode, zéro erreur)
- ✅ **Build Next.js**: Réussi (production ready)
- ⏳ Déployé en production (en attente)

### Notes techniques

**Modification du schéma** :

Avant :

```typescript
interface Ticket {
  id: string;
  title: string;
  description: string;
  status: TicketStatus;
  assignedTo: UserPublic | null;
  archived: boolean;
  createdAt: Date;
  updatedAt: Date;
}
```

Après :

```typescript
interface Ticket {
  id: string;
  title: string;
  description: string;
  status: TicketStatus;
  createdBy: UserPublic; // Nouveau champ
  assignedTo: UserPublic | null;
  archived: boolean;
  createdAt: Date;
  updatedAt: Date;
}
```
